# -*- coding: utf-8 -*-
"""A* para la busqueda del tesoro.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r-5XL8G2QFzLxtGJfgHJiuM12GTvy4p6
"""

from heapq import heappop, heappush

# Definir los movimientos posibles
moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # derecha, izquierda, abajo, arriba

# Obtener las coordenadas iniciales del jugador y del tesoro, así como la posición del guardia


def get_initial_state(grid):
    treasure_position = None
    start_position = None
    guard_positions = []

    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] == 'S':
                start_position = (i, j)
            elif grid[i][j] == 'T':
                treasure_position = (i, j)
            elif grid[i][j] == 'G':
                guard_positions.append((i, j))

    return start_position, treasure_position, guard_positions

# Heurística de distancia de Manhattan


def manhattan_distance(p1, p2):
    return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])

# A* adaptado para la búsqueda del tesoro


def a_star_treasure_hunt(grid):
    start_position, treasure_position, guard_positions = get_initial_state(grid)
    open_set = []
    # (costo total, posición actual, g, path)
    heappush(open_set, (0, start_position, 0, [start_position]))
    closed_set = set()

    while open_set:
        _, current_position, g, path = heappop(open_set)

        if current_position in closed_set:
            continue
        closed_set.add(current_position)

        # Si llegamos al tesoro
        if current_position == treasure_position:
            print("¡Tesoro encontrado!")
            print("Recorrido del jugador:", path)
            return path  # Costo total del camino

        # Expandir los movimientos posibles
        for move in moves:
            new_position = (current_position[0] + move[0], current_position[1] + move[1])

            # Dentro de la cuadrícula
            if 0 <= new_position[0] < len(grid) and 0 <= new_position[1] < len(grid[0]):
                if grid[new_position[0]][new_position[1]] != '#':  # No es un obstáculo
                    if new_position in guard_positions:  # No caer en la posición del guardia
                        continue

                    # Calcular h(n): distancia Manhattan al tesoro
                    h = manhattan_distance(new_position, treasure_position)

                    heappush(open_set, (g + 1 + h, new_position, g + 1, path + [new_position]))

    print("No se encontró una solución.")
    return None

if __name__ == "__main__":
    # Función para recibir la cuadrícula del usuario
    def get_grid_from_user():
        print("Introduce la cuadrícula (usa S para Start, T para Treasure, # para Obstáculo, . para Espacio vacío, G para Guardia):")
        grid = []
        while True:
            row = input()
            if not row:  # Salir con una línea vacía
                break
            grid.append(list(row))
        return grid

    # Ejecutar el algoritmo
    user_grid = get_grid_from_user()
    print(user_grid)
    a_star_treasure_hunt(user_grid)